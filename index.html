<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Seoul Building Map</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <style>
    html, body { height:100%; margin:0; }
    #map { position:absolute; inset:0; }
    .panel{
      position:absolute; left:12px; top:12px; width:360px; max-width:calc(100vw - 24px);
      background:rgba(255,255,255,.92);
      border:1px solid rgba(0,0,0,.08);
      border-radius:16px;
      box-shadow:0 10px 30px rgba(0,0,0,.18);
      padding:12px;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;
      z-index:1000;
      backdrop-filter: blur(6px);
    }
    .title-row{ display:flex; gap:8px; align-items:center; justify-content:space-between; }
    .title{ font-weight:800; font-size:16px; }
    .pill{
      padding:4px 8px; border-radius:999px; background:#f2f2f2; font-size:12px;
      border:1px solid rgba(0,0,0,.06);
    }
    .pill.ok{ background:#e8f7ee; color:#0b6b2f; }
    .pill.err{ background:#fdecec; color:#9b1c1c; }
    .pill.warn{ background:#fff4e5; color:#8a4b00; }
    .muted{ color:#666; }
    .small{ font-size:12px; }
    .hr{ height:1px; background:#eee; margin:10px 0; }

    button{
      border:1px solid #d8d8d8; background:#fff; border-radius:10px;
      padding:8px 10px; cursor:pointer;
    }
    button.primary{ background:#2563eb; border-color:#2563eb; color:#fff; }
    button.danger{ background:#fee2e2; border-color:#fecaca; color:#991b1b; }
    button:disabled{ opacity:.55; cursor:not-allowed; }

    progress{ width:100%; height:10px; }
    .error{ color:#b91c1c; }
  </style>
</head>

<body>
  <div id="map"></div>

  <div class="panel">
    <div class="title-row">
      <div class="title">Seoul Building Map</div>
      <span class="pill" id="statusPill">준비</span>
    </div>

    <div class="muted small" style="margin-top:4px;">
      ZIP 1회 다운로드 → 화면 범위(geohash6 셀)만 렌더링
    </div>

    <div class="hr"></div>

    <div class="small">
      <span class="pill" id="campaignPill">Campaign: -</span>
      <span class="pill ok" id="selPill">선택: 0</span>
      <span class="pill" id="assignPill">할당됨: 0</span>
    </div>

    <div style="display:flex; gap:8px; margin-top:10px;">
      <button class="primary" id="btnAddSelected">선택 추가</button>
      <button class="danger" id="btnClearSelected">선택 해제</button>
    </div>

    <div style="margin-top:10px;">
      <progress id="progress" value="0" max="100"></progress>
      <div class="muted small" id="progressText">-</div>
      <div class="error small" id="errorText"></div>
    </div>
  </div>

  <script>
    /**********************
     * 상태/DOM
     **********************/
    const elStatus = document.getElementById("statusPill");
    const elCampaign = document.getElementById("campaignPill");
    const elSel = document.getElementById("selPill");
    const elAssign = document.getElementById("assignPill");
    const elProgress = document.getElementById("progress");
    const elProgressText = document.getElementById("progressText");
    const elError = document.getElementById("errorText");
    const btnAddSelected = document.getElementById("btnAddSelected");
    const btnClearSelected = document.getElementById("btnClearSelected");

    function setStatus(text, cls) {
      elStatus.textContent = text;
      elStatus.className = "pill " + (cls || "");
    }
    function setProgress(pct, text) {
      elProgress.value = Number(pct || 0);
      elProgressText.textContent = text || "-";
    }
    function setError(text) {
      elError.textContent = text || "";
    }

    /**********************
     * Bridge state (Token + Parent Origin)
     **********************/
    let parentOrigin = "*";     // BL_INIT 수신 후 event.origin으로 고정
    let bridgeToken = null;     // BL_INIT으로 받음
    let vfReady = false;

    function postToParent(payload) {
      // VF가 실제 origin을 알려주기 전에는 '*'로 보내되, 이후엔 고정 origin 사용
      window.parent.postMessage(payload, parentOrigin || "*");
    }

    function logRecv(tag, event, data) {
      console.log(tag, {
        origin: event.origin,
        source: event.source,
        data
      });
    }

    /**********************
     * Map init
     **********************/
    const map = L.map("map", { preferCanvas: true }).setView([37.5665, 126.9780], 12);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const clusterLayer = L.markerClusterGroup({ disableClusteringAtZoom: 17, maxClusterRadius: 60 });
    map.addLayer(clusterLayer);

    /**********************
     * 선택/할당
     **********************/
    let currentCampaignId = null;
    const assignedKeys = new Set();
    const selectedKeys = new Set();
    const selectedPayloadByKey = new Map();

    function refreshUI() {
      elCampaign.textContent = "Campaign: " + (currentCampaignId ? String(currentCampaignId) : "-");
      elSel.textContent = "선택: " + selectedKeys.size;
      elAssign.textContent = "할당됨: " + assignedKeys.size;

      btnAddSelected.disabled = selectedKeys.size === 0;
      btnClearSelected.disabled = selectedKeys.size === 0;
    }

    function normKey(s) {
      return String(s ?? "").trim().toLowerCase().replace(/\s+/g, " ");
    }
    function getAddrForKey(p) {
      return p?.newPlatPlc ?? p?.["도로명대지위치"] ?? p?.platPlc ?? p?.["대지위치"] ?? p?.loc ?? "";
    }
    function makeBuildingKeyFromPoint(p) {
      const name = normKey(p?.["건물명"] ?? p?.bldNm__c ?? "");
      const addr = normKey(getAddrForKey(p));
      return `${name}|${addr}`;
    }

    function buildSfPayloadFromPoint(point) {
      return {
        bldNm__c: point?.["건물명"] ?? point?.bldNm__c ?? "",
        platPlc__c: point?.platPlc ?? point?.platPlc__c ?? "",
        newPlatPlc__c: point?.newPlatPlc ?? point?.newPlatPlc__c ?? "",
        dong__c: point?.["법정동"] ?? point?.dong ?? point?.dong__c ?? "",
        grndFlrCnt__c: point?.["지상층수"] ?? point?.grndFlrCnt ?? point?.grndFlrCnt__c ?? null,
        ugrndFlrCnt__c: point?.ugrndFlrCnt ?? point?.ugrndFlrCnt__c ?? null,
        totArea__c: point?.["연면적(m²)"] ?? point?.totArea__c ?? null,
        totAreapy__c: point?.["연면적(평)"] ?? point?.totAreapy__c ?? null,
        estimated_onfloorSurfaceArea__c: point?.["(추정) 지상 층당 면적"] ?? point?.estimated_onfloorSurfaceArea__c ?? null,
        etcPurps__c: point?.["기타용도"] ?? point?.etcPurps__c ?? "",
        mainPurpsCdNm__c: point?.["주용도"] ?? point?.mainPurpsCdNm__c ?? "",
        pmsDay__c: point?.["허가일"] ?? point?.pmsDay__c ?? "",
        stcnsDay__c: point?.["착공일"] ?? point?.stcnsDay__c ?? "",
        useAprDay__c: point?.["사용승인일"] ?? point?.useAprDay__c ?? ""
      };
    }

    /**********************
     * 마커 아이콘
     **********************/
    function makeDotIcon(colorHex) {
      const html = `<div style="
        width:14px;height:14px;border-radius:999px;
        background:${colorHex};
        border:2px solid rgba(255,255,255,0.95);
        box-shadow:0 1px 6px rgba(0,0,0,0.35);
      "></div>`;
      return L.divIcon({ className:"", html, iconSize:[14,14], iconAnchor:[7,7] });
    }
    const ICON_UNASSIGNED = makeDotIcon("#3b82f6");
    const ICON_SELECTED   = makeDotIcon("#22c55e");
    const ICON_ASSIGNED   = makeDotIcon("#9ca3af");

    function iconFor(key) {
      if (assignedKeys.has(key)) return ICON_ASSIGNED;
      if (selectedKeys.has(key)) return ICON_SELECTED;
      return ICON_UNASSIGNED;
    }

    function buildMarker(point) {
      const lat = Number(point?.lat);
      const lng = Number(point?.lng);
      if (!Number.isFinite(lat) || !Number.isFinite(lng)) return null;

      const key = normKey(makeBuildingKeyFromPoint(point));
      const m = L.marker([lat, lng], { icon: iconFor(key) });

      m.on("click", (ev) => {
        if (ev?.originalEvent) L.DomEvent.stopPropagation(ev);

        if (assignedKeys.has(key)) {
          setProgress(0, "이미 캠페인에 포함된 건물입니다.");
          return;
        }

        if (selectedKeys.has(key)) {
          selectedKeys.delete(key);
          selectedPayloadByKey.delete(key);
        } else {
          selectedKeys.add(key);
          selectedPayloadByKey.set(key, buildSfPayloadFromPoint(point));
        }

        m.setIcon(iconFor(key));
        refreshUI();
      });

      m.bindPopup(`<div style="min-width:240px;"><b>${String(point?.["건물명"]||"")}</b></div>`);
      return m;
    }

    /**********************
     * postMessage 브릿지 (전송/응답/타임아웃)
     **********************/
    const pending = new Map(); // requestId -> timeoutId

    function sendAddBuildings(buildings) {
      const requestId = String(Date.now());
      setError("");
      setStatus("전송중", "warn");
      setProgress(0, `Salesforce로 전송 중... (${buildings.length}개)`);

      if (!bridgeToken) {
        setStatus("오류", "err");
        setError("브릿지 토큰이 없습니다. (BL_INIT 수신 전)");
        console.log("Bridge token missing. Did VF send BL_INIT?");
        return;
      }

      const t = window.setTimeout(() => {
        pending.delete(requestId);
        setStatus("오류", "err");
        setError("Timeout: Salesforce 응답이 없습니다. (VF 브릿지 수신/응답 확인 필요)");
      }, 30000);
      pending.set(requestId, t);

      postToParent({
        type: "BL_ADD_BUILDINGS",
        token: bridgeToken,
        requestId,
        campaignId: currentCampaignId, // 참고용(신뢰는 VF가 가진 campaignId만)
        buildings
      });
    }

    function applyAssignedKeys(list) {
      assignedKeys.clear();
      for (const k of (Array.isArray(list) ? list : [])) {
        if (k) assignedKeys.add(normKey(k));
      }
      for (const k of Array.from(selectedKeys)) {
        if (assignedKeys.has(k)) {
          selectedKeys.delete(k);
          selectedPayloadByKey.delete(k);
        }
      }
      refreshUI();
    }

    window.addEventListener("message", (event) => {
      const data = event.data || {};
      if (!data.type) return;

      // ✅ VF -> Map 수신 로그(요청하신 “차단 이유 캡처”용)
      logRecv("Map recv", event, data);

      if (data.type === "BL_INIT") {
        // VF가 보내는 token을 저장하고, 이후 parentOrigin도 고정(보안 + 안정)
        parentOrigin = event.origin || "*";
        bridgeToken = data.payload?.token || null;
        vfReady = true;

        currentCampaignId = data.payload?.campaignId ?? null;
        applyAssignedKeys(data.payload?.assignedKeys ?? []);
        setStatus("표시중", "ok");
        setProgress(0, "캠페인 컨텍스트 수신 완료");
        console.log("Bridge ready", { parentOrigin, bridgeToken, campaignId: currentCampaignId });
        return;
      }

      if (data.type === "BL_ADD_BUILDINGS_ACK") {
        const requestId = data.payload?.requestId;
        if (requestId) setProgress(0, "VF에서 요청을 수신했습니다. 저장 처리 중...");
        return;
      }

      if (data.type === "BL_ADD_BUILDINGS_RESULT") {
        const payload = data.payload || data;
        const requestId = String(payload.requestId || "");

        const t = pending.get(requestId);
        if (t) window.clearTimeout(t);
        pending.delete(requestId);

        if (payload.campaignId) currentCampaignId = payload.campaignId;

        if (Array.isArray(payload.assignedKeys)) {
          applyAssignedKeys(payload.assignedKeys);
        }

        if (payload.status === "ERROR") {
          setStatus("오류", "err");
          setError(payload.message || "저장 실패");
          setProgress(0, "저장 실패");
        } else {
          setStatus("완료", "ok");
          setError("");
          setProgress(0, payload.message || "저장 완료");
          selectedKeys.clear();
          selectedPayloadByKey.clear();
          refreshUI();
        }
        return;
      }

      if (data.type === "BL_ERROR") {
        setStatus("오류", "err");
        setError(data.payload?.message || data.message || "오류");
      }
    });

    /**********************
     * 버튼 핸들러
     **********************/
    btnAddSelected.addEventListener("click", () => {
      if (selectedKeys.size === 0) return;
      if (!vfReady) {
        setStatus("대기", "warn");
        setError("VF 초기화(BL_INIT) 수신 전입니다. 잠시 후 다시 시도하세요.");
        return;
      }
      const buildings = Array.from(selectedPayloadByKey.values());
      sendAddBuildings(buildings);
    });

    btnClearSelected.addEventListener("click", () => {
      selectedKeys.clear();
      selectedPayloadByKey.clear();
      refreshUI();
      setProgress(0, "선택을 해제했습니다.");
    });

    /**********************
     * 시작: VF에 READY 알림
     **********************/
    refreshUI();
    setStatus("로딩중", "warn");

    // ✅ 최초 핸드셰이크: token 없이 BL_READY
    postToParent({ type: "BL_READY", version: 3 });

    setStatus("표시중", "ok");
  </script>
</body>
</html>
