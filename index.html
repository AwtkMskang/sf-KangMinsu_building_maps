<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Seoul Building Map</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"/>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

  <style>
    html, body { height:100%; margin:0; }
    #map { position:absolute; inset:0; }

    .panel{
      position:absolute; left:12px; top:12px; width:360px; max-width:calc(100vw - 24px);
      background:rgba(255,255,255,.92);
      border:1px solid rgba(0,0,0,.08);
      border-radius:16px;
      box-shadow:0 10px 30px rgba(0,0,0,.18);
      padding:12px;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial,sans-serif;
      z-index:1000;
      backdrop-filter: blur(6px);
    }
    .title-row{ display:flex; gap:8px; align-items:center; justify-content:space-between; }
    .title{ font-weight:800; font-size:16px; }
    .pill{
      padding:4px 8px; border-radius:999px; background:#f2f2f2; font-size:12px;
      border:1px solid rgba(0,0,0,.06);
      display:inline-block;
      margin-right:6px;
      margin-top:6px;
    }
    .pill.ok{ background:#e8f7ee; color:#0b6b2f; }
    .pill.err{ background:#fdecec; color:#9b1c1c; }
    .pill.warn{ background:#fff4e5; color:#8a4b00; }
    .muted{ color:#666; }
    .small{ font-size:12px; }
    .hr{ height:1px; background:#eee; margin:10px 0; }

    button{
      border:1px solid #d8d8d8; background:#fff; border-radius:10px;
      padding:8px 10px; cursor:pointer;
    }
    button.primary{ background:#2563eb; border-color:#2563eb; color:#fff; }
    button.danger{ background:#fee2e2; border-color:#fecaca; color:#991b1b; }
    button:disabled{ opacity:.55; cursor:not-allowed; }

    progress{ width:100%; height:10px; }
    .error{ color:#b91c1c; }
  </style>
</head>

<body>
  <div id="map"></div>

  <div class="panel">
    <div class="title-row">
      <div class="title">Seoul Building Map</div>
      <span class="pill" id="statusPill">준비</span>
    </div>

    <div class="muted small" style="margin-top:4px;">
      ZIP 1회 다운로드 → 화면 범위(geohash6 셀)만 렌더링(대신 bounds 기반 필터링으로 구현)
    </div>

    <div class="hr"></div>

    <div class="small">
      <span class="pill" id="campaignPill">Campaign: -</span>
      <span class="pill ok" id="selPill">선택: 0</span>
      <span class="pill" id="assignPill">할당됨: 0</span>
      <span class="pill" id="markerPill">화면 마커: 0</span>
    </div>

    <div style="display:flex; gap:8px; margin-top:10px;">
      <button class="primary" id="btnAddSelected">선택 추가</button>
      <button class="danger" id="btnClearSelected">선택 해제</button>
    </div>

    <div style="margin-top:10px;">
      <progress id="progress" value="0" max="100"></progress>
      <div class="muted small" id="progressText">-</div>
      <div class="error small" id="errorText"></div>
    </div>
  </div>

  <script>
    /**********************
     * 설정
     **********************/
    const DEBUG_BRIDGE = true;

    // ✅ 데이터 ZIP
    const DATA_ZIP_URL = "https://cdn.jsdelivr.net/gh/AwtkMskang/sf-building-map-data@main/seoul_geohash6.zip";

    // 너무 무거우면 화면에 올릴 최대 마커 수를 제한
    const MAX_MARKERS_ON_SCREEN = 20000;

    /**********************
     * DOM helpers
     **********************/
    const elStatus = document.getElementById("statusPill");
    const elCampaign = document.getElementById("campaignPill");
    const elSel = document.getElementById("selPill");
    const elAssign = document.getElementById("assignPill");
    const elMarker = document.getElementById("markerPill");
    const elProgress = document.getElementById("progress");
    const elProgressText = document.getElementById("progressText");
    const elError = document.getElementById("errorText");
    const btnAddSelected = document.getElementById("btnAddSelected");
    const btnClearSelected = document.getElementById("btnClearSelected");

    function setStatus(text, cls) {
      elStatus.textContent = text;
      elStatus.className = "pill " + (cls || "");
    }
    function setProgress(pct, text) {
      elProgress.value = Number(pct || 0);
      elProgressText.textContent = text || "-";
    }
    function setError(text) {
      elError.textContent = text || "";
    }

    /**********************
     * Bridge state
     **********************/
    let parentOrigin = "*";
    let bridgeToken = null;
    let vfReady = false;

    function postToParent(msg) {
      window.parent.postMessage(msg, parentOrigin || "*");
      if (DEBUG_BRIDGE) console.log("Map -> VF send", { targetOrigin: parentOrigin || "*", msg });
    }

    /**********************
     * Map init
     **********************/
    const map = L.map("map", { preferCanvas: true }).setView([37.5665, 126.9780], 12);
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const clusterLayer = L.markerClusterGroup({
      disableClusteringAtZoom: 17,
      maxClusterRadius: 60
    });
    map.addLayer(clusterLayer);

    /**********************
     * 선택/할당
     **********************/
    let currentCampaignId = null;

    const assignedKeys = new Set(); // "name|addr" (lower normalized)
    const selectedKeys = new Set(); // same as above
    const selectedPayloadByKey = new Map(); // key -> payload for SF

    function refreshUI(screenCount = null) {
      elCampaign.textContent = "Campaign: " + (currentCampaignId ? String(currentCampaignId) : "-");
      elSel.textContent = "선택: " + selectedKeys.size;
      elAssign.textContent = "할당됨: " + assignedKeys.size;
      if (screenCount !== null) elMarker.textContent = "화면 마커: " + screenCount;

      btnAddSelected.disabled = selectedKeys.size === 0;
      btnClearSelected.disabled = selectedKeys.size === 0;
    }

    function normKey(s) {
      return String(s ?? "").trim().toLowerCase().replace(/\s+/g, " ");
    }

    function getAddrForKey(p) {
      return p?.newPlatPlc ?? p?.["도로명대지위치"] ?? p?.platPlc ?? p?.["대지위치"] ?? p?.loc ?? "";
    }

    function makeBuildingKeyFromPoint(p) {
      const name = normKey(p?.["건물명"] ?? p?.bldNm__c ?? p?.bldNm ?? "");
      const addr = normKey(getAddrForKey(p));
      return `${name}|${addr}`;
    }

    function buildSfPayloadFromPoint(point) {
      return {
        bldNm__c: point?.["건물명"] ?? point?.bldNm__c ?? "",
        platPlc__c: point?.platPlc ?? point?.platPlc__c ?? "",
        newPlatPlc__c: point?.newPlatPlc ?? point?.newPlatPlc__c ?? "",
        dong__c: point?.["법정동"] ?? point?.dong ?? point?.dong__c ?? "",
        grndFlrCnt__c: point?.["지상층수"] ?? point?.grndFlrCnt ?? point?.grndFlrCnt__c ?? null,
        ugrndFlrCnt__c: point?.ugrndFlrCnt ?? point?.ugrndFlrCnt__c ?? null,
        totArea__c: point?.["연면적(m²)"] ?? point?.totArea__c ?? null,
        totAreapy__c: point?.["연면적(평)"] ?? point?.totAreapy__c ?? null,
        estimated_onfloorSurfaceArea__c: point?.["(추정) 지상 층당 면적"] ?? point?.estimated_onfloorSurfaceArea__c ?? null,
        etcPurps__c: point?.["기타용도"] ?? point?.etcPurps__c ?? "",
        mainPurpsCdNm__c: point?.["주용도"] ?? point?.mainPurpsCdNm__c ?? "",
        pmsDay__c: point?.["허가일"] ?? point?.pmsDay__c ?? "",
        stcnsDay__c: point?.["착공일"] ?? point?.stcnsDay__c ?? "",
        useAprDay__c: point?.["사용승인일"] ?? point?.useAprDay__c ?? ""
      };
    }

    /**********************
     * 마커 아이콘
     **********************/
    function makeDotIcon(colorHex) {
      const html = `<div style="
        width:14px;height:14px;border-radius:999px;
        background:${colorHex};
        border:2px solid rgba(255,255,255,0.95);
        box-shadow:0 1px 6px rgba(0,0,0,0.35);
      "></div>`;
      return L.divIcon({ className:"", html, iconSize:[14,14], iconAnchor:[7,7] });
    }
    const ICON_UNASSIGNED = makeDotIcon("#3b82f6");
    const ICON_SELECTED   = makeDotIcon("#22c55e");
    const ICON_ASSIGNED   = makeDotIcon("#9ca3af");

    function iconFor(key) {
      if (assignedKeys.has(key)) return ICON_ASSIGNED;
      if (selectedKeys.has(key)) return ICON_SELECTED;
      return ICON_UNASSIGNED;
    }

    /**********************
     * 데이터 로딩 (ZIP -> points[])
     **********************/
    let allPoints = [];          // 원시 포인트 배열 (lat/lng + 속성)
    let allMarkers = [];         // { key, lat, lng, marker, point }
    let dataLoaded = false;
    let rendering = false;

    function detectLatLng(obj) {
      // 가능한 필드 후보들을 최대한 넓게 지원
      const lat =
        obj.lat ?? obj.latitude ?? obj.Lat ?? obj.LAT ??
        obj["위도"] ?? obj["lat"] ?? obj["LATITUDE"];
      const lng =
        obj.lng ?? obj.lon ?? obj.longitude ?? obj.Lng ?? obj.LON ??
        obj["경도"] ?? obj["lng"] ?? obj["LONGITUDE"];
      const la = Number(lat);
      const lo = Number(lng);
      if (!Number.isFinite(la) || !Number.isFinite(lo)) return null;
      return { lat: la, lng: lo };
    }

    function parseCSV(text) {
      // 아주 단순 CSV 파서(따옴표 내부 콤마 케이스는 최소 처리)
      const lines = text.split(/\r?\n/).filter(Boolean);
      if (lines.length < 2) return [];
      const header = splitCSVLine(lines[0]);
      const out = [];
      for (let i = 1; i < lines.length; i++) {
        const cols = splitCSVLine(lines[i]);
        const row = {};
        for (let j = 0; j < header.length; j++) {
          row[header[j]] = cols[j] ?? "";
        }
        out.push(row);
      }
      return out;
    }

    function splitCSVLine(line) {
      const out = [];
      let cur = "";
      let inQ = false;
      for (let i = 0; i < line.length; i++) {
        const ch = line[i];
        if (ch === '"') {
          if (inQ && line[i+1] === '"') { cur += '"'; i++; }
          else inQ = !inQ;
        } else if (ch === ',' && !inQ) {
          out.push(cur); cur = "";
        } else {
          cur += ch;
        }
      }
      out.push(cur);
      return out.map(s => s.trim());
    }

    function normalizePoint(obj) {
      const ll = detectLatLng(obj);
      if (!ll) return null;
      // lat/lng를 표준화하여 저장
      return { ...obj, lat: ll.lat, lng: ll.lng };
    }

    async function loadZipOnce() {
      setError("");
      setStatus("로딩중", "warn");
      setProgress(2, "데이터 ZIP 다운로드 시작...");

      const resp = await fetch(DATA_ZIP_URL, { cache: "no-store" });
      if (!resp.ok) throw new Error("ZIP fetch failed: " + resp.status + " " + resp.statusText);

      const buf = await resp.arrayBuffer();
      setProgress(10, "ZIP 압축 해제 중...");

      const zip = await JSZip.loadAsync(buf);
      const files = Object.keys(zip.files).filter(n => !zip.files[n].dir);

      if (files.length === 0) throw new Error("ZIP has no files");

      // 파일을 전부 읽어서 points로 합칩니다.
      // (용량이 크면 시간이 걸리므로 진행률 표시)
      let loaded = 0;
      const points = [];

      for (const fname of files) {
        const f = zip.files[fname];
        const text = await f.async("text");

        let rows = [];
        const t = text.trim();
        try {
          if (t.startsWith("[")) {
            rows = JSON.parse(t);
          } else if (t.startsWith("{")) {
            const one = JSON.parse(t);
            rows = Array.isArray(one) ? one : (one.features ? one.features.map(x => x.properties || x) : [one]);
          } else {
            rows = parseCSV(text);
          }
        } catch (e) {
          // 포맷 불명 파일은 스킵 (필요하면 콘솔로 확인)
          console.log("Skip file parse error:", fname, e);
          rows = [];
        }

        for (const r of rows) {
          const p = normalizePoint(r);
          if (p) points.push(p);
        }

        loaded++;
        const pct = 10 + Math.floor((loaded / files.length) * 70);
        setProgress(pct, `파일 로딩 ${loaded}/${files.length}... (누적 points=${points.length})`);
      }

      allPoints = points;
      dataLoaded = true;

      setProgress(85, "마커 생성 준비...");
      console.log("Data loaded", { files: files.length, points: allPoints.length });
    }

    function buildAllMarkersOnce() {
      allMarkers = [];

      for (const p of allPoints) {
        const key = normKey(makeBuildingKeyFromPoint(p));
        if (!key || key === "|") continue;

        const m = L.marker([p.lat, p.lng], { icon: iconFor(key) });

        m.on("click", (ev) => {
          if (ev?.originalEvent) L.DomEvent.stopPropagation(ev);

          if (assignedKeys.has(key)) {
            setProgress(0, "이미 캠페인에 포함된 건물입니다.");
            return;
          }

          if (selectedKeys.has(key)) {
            selectedKeys.delete(key);
            selectedPayloadByKey.delete(key);
          } else {
            selectedKeys.add(key);
            selectedPayloadByKey.set(key, buildSfPayloadFromPoint(p));
          }

          m.setIcon(iconFor(key));
          refreshUI(clusterLayer.getLayers().length);
        });

        const title = (p["건물명"] ?? p.bldNm__c ?? p.bldNm ?? "").toString();
        const addr = getAddrForKey(p).toString();
        m.bindPopup(`<div style="min-width:240px;"><b>${escapeHtml(title)}</b><div class="small muted">${escapeHtml(addr)}</div></div>`);

        allMarkers.push({ key, lat: p.lat, lng: p.lng, marker: m, point: p });
      }
      console.log("Markers built", { markers: allMarkers.length });
    }

    function escapeHtml(s) {
      return String(s ?? "")
        .replaceAll("&","&amp;").replaceAll("<","&lt;")
        .replaceAll(">","&gt;").replaceAll('"',"&quot;").replaceAll("'","&#39;");
    }

    function refreshMarkerIconsForAssignedSelected() {
      // assigned/selected 변화 반영
      for (const it of allMarkers) {
        it.marker.setIcon(iconFor(it.key));
      }
    }

    function renderMarkersInView() {
      if (!dataLoaded || rendering) return;
      rendering = true;

      const b = map.getBounds();
      const inView = [];

      for (const it of allMarkers) {
        if (b.contains([it.lat, it.lng])) inView.push(it);
        if (inView.length >= MAX_MARKERS_ON_SCREEN) break;
      }

      clusterLayer.clearLayers();
      clusterLayer.addLayers(inView.map(x => x.marker));

      refreshUI(inView.length);
      setProgress(100, `화면 렌더링 완료 (전체=${allMarkers.length}, 화면=${inView.length})`);
      setStatus("표시중", "ok");

      rendering = false;
    }

    let renderTimer = null;
    function scheduleRender() {
      if (renderTimer) clearTimeout(renderTimer);
      renderTimer = setTimeout(renderMarkersInView, 120);
    }

    map.on("moveend zoomend", scheduleRender);

    /**********************
     * VF 브릿지: assignedKeys 반영
     **********************/
    function applyAssignedKeys(list) {
      assignedKeys.clear();
      for (const k of (Array.isArray(list) ? list : [])) {
        if (k) assignedKeys.add(normKey(k));
      }
      // 선택 중 assigned로 바뀐 것은 제거
      for (const k of Array.from(selectedKeys)) {
        if (assignedKeys.has(k)) {
          selectedKeys.delete(k);
          selectedPayloadByKey.delete(k);
        }
      }
      if (dataLoaded) {
        refreshMarkerIconsForAssignedSelected();
        scheduleRender();
      }
      refreshUI(clusterLayer.getLayers().length);
    }

    /**********************
     * 저장 요청/응답
     **********************/
    const pending = new Map(); // requestId -> timeoutId

    function sendAddBuildings(buildings) {
      const requestId = String(Date.now());
      setError("");
      setStatus("전송중", "warn");
      setProgress(0, `Salesforce로 전송 중... (${buildings.length}개)`);

      if (!bridgeToken) {
        setStatus("오류", "err");
        setError("브릿지 토큰이 없습니다. (BL_INIT 수신 전)");
        console.log("Bridge token missing. Did VF send BL_INIT?");
        return;
      }

      const t = window.setTimeout(() => {
        pending.delete(requestId);
        setStatus("오류", "err");
        setError("Timeout: VF로부터 ACK/RESULT를 받지 못했습니다.");
      }, 30000);
      pending.set(requestId, t);

      postToParent({
        type: "BL_ADD_BUILDINGS",
        token: bridgeToken,
        requestId,
        campaignId: currentCampaignId,
        buildings
      });
    }

    /**********************
     * UI 버튼
     **********************/
    btnAddSelected.addEventListener("click", () => {
      if (selectedKeys.size === 0) return;
      if (!vfReady) {
        setStatus("대기", "warn");
        setError("VF 초기화(BL_INIT) 수신 전입니다. 잠시 후 다시 시도하세요.");
        return;
      }
      const buildings = Array.from(selectedPayloadByKey.values());
      sendAddBuildings(buildings);
    });

    btnClearSelected.addEventListener("click", () => {
      selectedKeys.clear();
      selectedPayloadByKey.clear();
      if (dataLoaded) refreshMarkerIconsForAssignedSelected();
      refreshUI(clusterLayer.getLayers().length);
      setProgress(0, "선택을 해제했습니다.");
    });

    /**********************
     * postMessage 수신
     **********************/
    window.addEventListener("message", (event) => {
      const data = event.data || {};
      if (!data.type) return;

      if (DEBUG_BRIDGE) console.log("Map recv", { origin: event.origin, data });

      if (data.type === "BL_INIT") {
        parentOrigin = event.origin || "*";
        bridgeToken = data.payload?.token || null;
        vfReady = true;

        currentCampaignId = data.payload?.campaignId ?? null;
        applyAssignedKeys(data.payload?.assignedKeys ?? []);

        setStatus("표시중", "ok");
        setProgress(0, "캠페인 컨텍스트 수신 완료");
        console.log("Bridge ready", { parentOrigin, bridgeToken, campaignId: currentCampaignId });
        return;
      }

      if (data.type === "BL_ADD_BUILDINGS_ACK") {
        const requestId = data.payload?.requestId;
        if (requestId) setProgress(0, "VF에서 요청 수신(ACK). 저장 처리 중...");
        return;
      }

      if (data.type === "BL_ADD_BUILDINGS_RESULT") {
        const payload = data.payload || data;
        const requestId = String(payload.requestId || "");

        const t = pending.get(requestId);
        if (t) window.clearTimeout(t);
        pending.delete(requestId);

        if (payload.campaignId) currentCampaignId = payload.campaignId;
        if (Array.isArray(payload.assignedKeys)) applyAssignedKeys(payload.assignedKeys);

        if (payload.status === "ERROR") {
          setStatus("오류", "err");
          setError(payload.message || "저장 실패");
          setProgress(0, "저장 실패");
        } else {
          setStatus("완료", "ok");
          setError("");
          setProgress(0, payload.message || "저장 완료");

          selectedKeys.clear();
          selectedPayloadByKey.clear();
          if (dataLoaded) refreshMarkerIconsForAssignedSelected();
          refreshUI(clusterLayer.getLayers().length);
        }
        return;
      }

      if (data.type === "BL_ERROR") {
        setStatus("오류", "err");
        setError(data.payload?.message || data.message || "오류");
      }
    });

    /**********************
     * 시작
     **********************/
    (async function boot() {
      try {
        refreshUI(0);
        setStatus("로딩중", "warn");

        // 1) VF에 READY
        postToParent({ type: "BL_READY", version: 3 });

        // 2) 데이터 ZIP 로딩 + 마커 생성
        await loadZipOnce();
        setProgress(90, "마커 생성 중...");
        buildAllMarkersOnce();

        // 3) 최초 렌더
        scheduleRender();
      } catch (e) {
        console.log(e);
        setStatus("오류", "err");
        setError(String(e?.message || e));
        setProgress(0, "데이터 로딩 실패");
      }
    })();
  </script>
</body>
</html>
